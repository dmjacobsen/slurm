<!--#include virtual="header.txt"-->

<h1><a name="top">cli_filter Plugin API</a></h1>

<h2> Overview</h2>
<p> This document describes Slurm job submit plugins and the API that
defines them. It is intended as a resource to programmers wishing to write
their own Slurm cli_filter plugins. This is version 100 of the API.</p>

<p> The purpose of the cli_filter plugins are to provide programmatic hooks
during the execution of the <b>salloc</b>, <b>sbatch</b>, and <b>srun</b>
command line interface (CLI) programs.  Three hooks are defined:
<ul>
<li><b>setup_defaults</b> &mdash; Called before any option processing is done,
<i>per job-pack</i>, allowing a plugin to replace default option values.</li>
<li><b>pre_submit</b> &mdash;  Called after option processing <i>per job-pack</i>
but before any communication is made with the slurm controller.  This location
is ideal for policy enforcement because the plugin can read all the options
supplied by the user (as well as the environment) - thus invalid job requests
can be stopped before they ever reach the slurmctld.</li>
<li><b>post_submit</b> &mdash; Called after the jobid (and, in the case of
<b>srun</b>, after the stepid) is generated, and typically before or in
parallel with job execution.  In combination with data collected in the
pre_submit() hook, this is an ideal location for logging activity.</li>

cli_filter plugins vary from the <a href="job_submit_plugins.html">job_submit plugin</a>
as it is entirely executed client-side, whereas job_submit is processed server-
side (within the slurm controller).  The benefit of the cli_filter is that it has
access to all command line options in a simple and consistent interface as well
as being safer to run disruptive operations (e.g., quota checks or other long
running operations you might want to use for integrating policy decisions), which
might be problematic if run from the controller.  The disadvantage of the cli_filter
is that it must not be relied upon for security purposes as an enterprising user can
circumvent it simply by providing their own build of sbatch/salloc/srun.  If you plan
to use the cli_filter for managing policies, you should also configure a job_submit
plugin to reinforce those policies.

<p>Slurm cli_filter plugins must conform to the
Slurm Plugin API with the following specifications:</p>

<p><span class="commandline">const char
plugin_name[]="<i>full&nbsp;text&nbsp;name</i>"</span>
<p style="margin-left:.2in">
A free-formatted ASCII text string that identifies the plugin.

<p><span class="commandline">const char
plugin_type[]="<i>major/minor</i>"</span><br>
<p style="margin-left:.2in">
The major type must be &quot;cli_filter.&quot;
The minor type can be any suitable name for the type of job submission package.
We include samples in the Slurm distribution for
<ul>
<li><b>lua</b> &mdash; Interface to <a href="http://www.lua.org">Lua</a> scripts
implementing these functions (actually a slight variation of them). Sample Lua
scripts can be found with the Slurm distribution in the directory
<i>contribs/lua</i>. The default installation location of the Lua scripts is
the same location as the Slurm configuration file, <i>slurm.conf</i>.</li>
<li><b>none</b> &mdash; An empty plugin with no actions taken, a useful starting
template for a new plugin.</li>
<li><b>syslog</b> &mdash; A plugin to identify all user or otherwise selected
options, generate a json document from them, and syslog the result.  Useful
for logging all salloc, sbatch, and srun activity.</li>
</ul>

<p><span class="commandline">const uint32_t plugin_version</span><br>
If specified, identifies the version of Slurm used to build this plugin and
any attempt to load the plugin from a different version of Slurm will result
in an error.
If not specified, then the plugin may be loadeed by Slurm commands and
daemons from any version, however this may result in difficult to diagnose
failures due to changes in the arguments to plugin functions or changes
in other Slurm functions used by the plugin.</p>

<p>Slurm can be configured to use multiple cli_filter plugins if desired,
however the lua plugin will only execute one lua script named "cli_filter.lua"
located in the default script directory (typically the subdirectory "etc" of
the installation directory).</p>


<h2>API Functions</h2>
<p>All of the following functions are required. Functions which are not
implemented must be stubbed.

<p class="commandline"> int init (void)
<p style="margin-left:.2in"><b>Description</b>:<br>
  Called when the plugin is loaded, before any other functions are
  called. Put global initialization here.
<p style="margin-left:.2in"><b>Returns</b>: <br>
  <span class="commandline">SLURM_SUCCESS</span> on success, or<br>
  <span class="commandline">SLURM_ERROR</span> on failure.</p>

<p class="commandline"> void fini (void)
<p style="margin-left:.2in"><b>Description</b>:<br>
  Called when the plugin is removed. Clear any allocated storage here.
<p style="margin-left:.2in"><b>Returns</b>: None.</p>

<p><b>Note</b>: These init and fini functions are not the same as those
described in the <span class="commandline">dlopen (3)</span> system library.
The C run-time system co-opts those symbols for its own initialization.
The system <span class="commandline">_init()</span> is called before the Slurm
<span class="commandline">init()</span>, and the Slurm
<span class="commandline">fini()</span> is called before the system's
<span class="commandline">_fini()</span>.</p>

<p class="commandline">
int setup_defaults(slurm_opt_t *options, bool early)
<p style="margin-left:.2in"><b>Description</b>:<br>
This function is called by the salloc, sbatch, or srun command line interface
(CLI) programs shortly before processing any options from the environment,
command line, or script (#SBATCH). The hook may be run multiple times per job-pack,
once for an early pass (if implemented by the CLI), and again for the main pass.
The options and early arguments are meant to be passed to <b>slurm_option_set()</b>
which will set the option if it is in the appropriate pass.  Failures to set
an option may be a symptom of trying to set the option on the wrong pass.  Given
that you should not return SLURM_ERROR simply because of a failure to set an option.
<p style="margin-left:.2in"><b>Arguments</b>: <br>
<span class="commandline">options</span>
(input) slurm option data structure; meant to be passed to the slurm_option_* API
within <i>src/common/slurm_opt.h</i>.<br>
<span class="commandline">early</span>
(input) boolean indicating if this is the early pass or not; meant to be passed to
the slurm_option_* API within <i>src/common/slurm_opt.h</i>.<br>
<p style="margin-left:.2in"><b>Returns</b>: <br>
<span class="commandline">SLURM_SUCCESS</span> on success, or<br>
<span class="commandline">SLURM_ERROR</span> on failure, will terminate execution
of the CLI.

<p class="commandline">
int pre_submit(slurm_opt_t *options, int pack_offset)
<p style="margin-left:.2in"><b>Description</b>:<br>
This function is called by the CLI after option processing but before any
communication with the slurmctld is made.  This is after all setup_defaults()
hooks are executed (for the current job-pack), environment variables processed,
command line options and #SBATCH directives interpreted. <b>pre_submit()</b> is
called before any parts of the data structure are rewritten, so it is safe to
both read and write or unset any options from the plugin that you desire.
Note that post_submit() cannot safely read (or write) the options, so you should
save any state for logging in post_submit() during pre_submit(). This function is
called once per job pack.
<p style="margin-left:.2in"><b>Arguments</b>: <br>
<span class="commandline">options</span>
(input/output) the job allocation request specifications.<br>
<span class="commandline">pack_offset</span>
(input) integer value for the current pack offset; should be used as a key when
storing data for communication between pre_submit() and post_submit().<br>
<p style="margin-left:.2in"><b>Returns</b>: <br>
<span class="commandline">SLURM_SUCCESS</span> on success, or<br>
<span class="commandline">SLURM_ERROR</span> on failure, will terminate execution
of the CLI.

<p class="commandline">
void post_submit(int pack_offset, uint32_t jobid, uint32_t stepid)
<p style="margin-left:.2in"><b>Description</b>:<br>
This function is called by the CLI after a jobid (and, if srun, a stepid) has
been assigned by the controller.  It is no longer safe to read or write to the
options data structure, so it has been removed from this function.  You should
save any state you need in pre_submit() using pack_offset as a key and access
it here.  This function is called once per job-pack.
<p style="margin-left:.2in"><b>Arguments</b>: <br>
<span class="commandline">options</span>
<span class="commandline">pack_offset</span>
(input) integer value for the current pack offset; should be used as a key when
storing data for communication between pre_submit() and post_submit().<br>
<span class="commandline">jobid</span>
(input) job id of the job<br>
<span class="commandline">stepid</span>
(input) step id of the job if appropriate, NO_VAL otherwise<br>

<h2>Lua Functions</h2>
<p>The Lua functions differ slightly from those implemented in C for
better ease of use. Sample Lua scripts can be found with the Slurm distribution
in the directory <i>contribs/lua</i>. The default installation location of
the Lua scripts is the same location as the Slurm configuration file,
<i>slurm.conf</i>.
Reading and writing of job environment variables using Lua is possible
by referencing the environment variables directly.  This is possible because
the lua interpreter is running within the CLI execution.
For example:<br>
if (os.getenv("LANGUAGE") == "en_US") then<br>
....</p>

<p class="commandline">
setup_defaults(args)
<p style="margin-left:.2in"><b>Description</b>:<br>
This function is called by the salloc, sbatch, or srun command line interface
(CLI) programs shortly before processing any options from the environment,
command line, or script (#SBATCH). The hook may be run multiple times per job-pack,
once for an early pass (if implemented by the CLI), and again for the main pass.
The args table can be read and written to using the name of the desired option
as a key, e.g., if (args['partition'] == "foo"), or args['partition'] = "bar".
Note that given the early execution of this hook, it really only makes sense to
write to options.
<p style="margin-left:.2in"><b>Arguments</b>: <br>
<span class="commandline">args</span>
(input) lua dynamic table allowing all arguments (by long name) to be read or written
to.<br>
<p style="margin-left:.2in"><b>Returns</b>: <br>
<span class="commandline">slurm.SUCCESS</span> on success, or<br>
<span class="commandline">slurm.ERROR</span> on failure, will terminate execution
of the CLI.

<p class="commandline">
pre_submit(args, offset)
<p style="margin-left:.2in"><b>Description</b>:<br>
This function is called by the salloc, sbatch, or srun command line interface
(CLI) programs after processing any options from the setup_defaults(),
environment, command line, or script (#SBATCH). The hook is run once per
job-pack (with varying offset). The args table can be read and written to using
the name of the desired option as a key, e.g., if (args['partition'] == "foo"),
or args['partition'] = "bar". In addition to all the arguments in sbatch and
srun the args table will provide a table of the specified script/program and
its arguments via args['argv'].  Note that args.argv is read-only.
<p style="margin-left:.2in"><b>Arguments</b>: <br>
<span class="commandline">args</span>
(input/output) lua dynamic table allowing all arguments (by long name) to be
read or written.<br>
<span class="commandline">offset</span>
(input) integer offset identifying to which job-pack these arguments refer.
Should be used as a key when storing data from pre_submit() for final processing
in post_submit().<br>
<p style="margin-left:.2in"><b>Returns</b>: <br>
<span class="commandline">slurm.SUCCESS</span> on success, or<br>
<span class="commandline">slurm.ERROR</span> on failure, will terminate execution
of the CLI.

<p class="commandline">
post_submit(offset, jobid, stepid)
<p style="margin-left:.2in"><b>Description</b>:<br>
This function is called by the salloc, sbatch, or srun command line interface
(CLI) programs after receiving a response from the slurmctld process with the
job metadata (jobid, stepid).  The args interface is not available here as it
is unsafe to read or write arguments at this stage. Argument data should be
stored in the pre_submit() and retrieved here for final processing.
<p style="margin-left:.2in"><b>Arguments</b>: <br>
<span class="commandline">offset</span>
(input) integer offset identifying to which job-pack these arguments refer.
Should be used as a key when retrieving data stored in pre_submit() for final
processing here.<br>
<span class="commandline">jobid</span>
(input) integer jobid (always primary id for all hetjob packs).<br>
<span class="commandline">stepid</span>
(input) the integral job step id if applicable, otherwise set to slurm.NO_VAL.
<br>
<p style="margin-left:.2in"><b>Returns</b>: NOTHING<br>

<h3>Convenience Lua APIs</h3>
A number of useful interfaces for accessing or formatting bulk data are
available in the lua interface.

<p class="commandline">
slurm.cli_store(offset, stringdata)
<p style="margin-left:.2in"><b>Description</b>:<br>
Method for storing data for during pre_submit() by job-pack offset. Only
makes sense to call this during pre_submit(). Can be used in conjunction
with <b>slurm.json_cli_options</b> to prepare logging data.
<p style="margin-left:.2in"><b>Arguments</b>:<br>
<span class="commandline">offset</span>
(input) key to store data under, should be the hetjob offset from pre_submit()
<br>
<span class="commandline">stringdata</span>
(input) arbitrary character string to store.<br>
<p style="margin-left:.2in"><b>Returns</b>: NOTHING<br>

<p class="commandline">
slurm.cli_retrieve(offset)
<p style="margin-left:.2in"><b>Description</b>:<br>
Method for retrieving data previously stored with slurm.cli_store(). Use
the jobpack offset to key which data to return.
<p style="margin-left:.2in"><b>Arguments</b>:<br>
<span class="commandline">offset</span>
(input) key to store data under, should be the hetjob offset from post_submit()
<br>
<span class="commandline">stringdata</span>
(input) arbitrary character string to store.<br>
<p style="margin-left:.2in"><b>Returns</b>:<br>
string data stored previously using the specified offset key<br>

<p class="commandline">
slurm.json_cli_options(offset)
<p style="margin-left:.2in"><b>Description</b>:<br>
Method to generate a json document containing all of the <i>set</i> options. Can only be called
from pre_submit()
<p style="margin-left:.2in"><b>Arguments</b>:<br>
<span class="commandline">args</span>
(input) the args variable passed to pre_submit()
<br>
<p style="margin-left:.2in"><b>Returns</b>:<br>
character string of a json document containing all set options
<br>

<p class="commandline">
slurm.json_env()
<p style="margin-left:.2in"><b>Description</b>:<br>
Method to generate a json document containing the entire environment excluding SLURM_* variables (since
those are presumably captured in slurm.json_cli_options() in their fully resolved form).
from pre_submit()
<p style="margin-left:.2in"><b>Arguments</b>: NONE<br>
<p style="margin-left:.2in"><b>Returns</b>:<br>
character string of a json document containing the environment
<br>

<h2>Building</h2>
<p>Generally using a lua interface for a cli_filter plugin is best:
It is simple to write and maintain with minimal dependencies upon the Slurm
data structures.
The limited APIs of the CLI clients does limit the opportunities for
getting more functionality by writing a C plugin &emdash; basically the lua
interface already exposes everything that is available.
The simplest way to build a C plugin would be to just replace one of the
cli_filter plugins included in the Slurm distribution with your own code
(i.e. use a patch with your own code).
Then just build and install Slurm with that new code.
Building a new plugin outside of the Slurm distribution is possible, but
far more complex.
It also requires access to a multitude of Slurm header files as shown in the
proceedure shown in the <a href="job_submit_plugins.html#job_modify_manualbuild">
job submit plugins manual build section</a>.
</p>

<p style="text-align:center;">Last modified 26 March 2019</p>

<!--#include virtual="footer.txt"-->
